# Read File Into Vector
snippet readfile
	std::vector<char> v;
	if (FILE *${2:fp} = fopen(${1:"filename"}, "r")) {
		char buf[1024];
		while (size_t len = fread(buf, 1, sizeof(buf), $2))
			v.insert(v.end(), buf, buf + len);
		fclose($2);
	}${3}
# std::map
snippet map
	std::map<${1:key}, ${2:value}> ${3:map};
# std::vector
snippet vector
	std::vector<${1:int}> ${2:v};
# Namespace
snippet ns
	namespace ${1:`Filename('', 'my')`} {
		${2}
	} /* $1 */
# Class
snippet cl
	class ${1:`Filename('$1_t', 'name')`} {
	public:
		$1 (${2:arguments});
		virtual ~$1 ();

	private:
		${3:/* data */}
	};
snippet fori
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4:/* code */}
	}

snippet main
	#include<cstdio>

	#define MAXX ${1:100111}
	int i,j,k,l,r,m,n;
	int the[MAXX];

	int main()
	{
		${1}
		return 0;
	}
snippet for1
	for(${1:i}=1;$1<=${2:n};${3:++$1})
		${4}

snippet set
	std::set<${1:int}>${2:set};
snippet mset
	std::multiset<${1:int}>${2:set};
snippet pair
	std::pair<${1:int},${2:int}>$3;

#segment tree
snippet segtree
	class SegTree
	{
	#define MAXX ${1:100111}
	#define MAX (MAXX<<2)
	#define lson (id<<1)
	#define rson (id<<1|1)
	#define mid ((l+r)>>1)
	#define lc lson,l,mid
	#define rc rson,mid+1,r
	#define llen (mid-l+1)	//lson length
	#define rlen (r-mid)	//rson length
	#define clen (r-l+1)	//current length
		class Node
		{
			public:
				//define here
	
				friend Node operator+(const Node &l,const Node &r)//merge
				{
					//define here
					return Node();
				}
				void set(/*int the*/)
				{
					//define here
				}
		}tree[MAX];
		int len;
	
		void make(int id,int l,int r,${2:int *}${3:the})
		{
			//define here
			if(l==r)
			{
				tree[id].set($3[l]);
				return;
			}
			make(lc,$3);
			make(rc,$3);
			tree[id]=tree[lson]+tree[rson];
		}
		void down(int id,int l,int r)
		{
			if(l==r)
				return;
			//define here
		}
		void update(int id,int l,int r,int ll,int rr,/*define*/int val)
		{
			down(id,l,r);
			if(ll<=l && r<=rr)
				//define here
			else
			{
				if(ll<=mid)
					update(lc,ll,rr,val);
				if(rr>mid)
					update(rc,ll,rr,val);
				tree[id]=tree[lson]+tree[rson];
			}
		}
		Node query(int id,int l,int r,int ll,int rr)
		{
			down(id,l,r);
			if(ll<=l && r<=rr)
				return tree[id];
			if(rr<=mid)
				return query(lc,ll,rr);
			if(ll>mid)
				return query(rc,ll,rr);
			return query(lc,ll,rr)+query(rc,ll,rr);
		}
	
		public:
		int opt;//specify the type of operation
	
		void init(int len,$2$3)
		{
			this->len=len;
			make(1,1,len,$3);
		}
		/*
		int qry(int l,int r)
		{
			static Node re;
			re=query(1,1,len,l,r);
			return re.sum;
		}
		void upd(int l,int r,int val)
		{
			update(1,1,len,l,r,val);
		}
		*/
	#undef MAXX
	#undef MAX
	#undef lson
	#undef rson
	#undef lc
	#undef rc
	#undef mid
	#undef llen
	#undef rlen
	#undef clen
	}tree;

snippet edge
	#define MAXN ${1:100111}
	#define MAXM ${2:1000111}
	
	int edge[MAXN],next[MAXM],to[MAXM],cost[MAXM],cnt;
	
	void add(int a,int b,int c)
	{
		to[++cnt]=b;
		cost[cnt]=c;
		next[cnt]=edge[a];
		edge[a]=cnt;
	}

snippet dijkstra
	#include<cstring>
	#include<set>
	#include<algorithm>
	
	inline void dijkstra(int n,int s,int *dist)
	{
		typedef std::pair<int,int>pii;
		std::multiset<pii>q;
		static int a,b,i;
		memset(dist,0x3f,(n+1)*(sizeof(int)));
	
		dist[s]=0;
		q.insert(pii(0,s));
		while(!q.empty())
		{
			a=q.begin()->second;
			b=q.begin()->first;
			q.erase(q.begin());
			if(b>dist[a])
				continue;
			for(i=edge[a];i;i=next[i])
				if(dist[to[i]]>b+cost[i])
				{
					dist[to[i]]=b+cost[i];
					q.insert(pii(dist[to[i]],to[i]));
				}
		}
	}


