#todo:
#	data structure
#		HLD
#		LCT
#		BIT
#		mergeable heap
#		sparse table
#	geometrics
#		point & vector
#		polygons
#		k-d tree
#		3D
#	graph
#		netflow	
#		scc
#		SPFA
#	string
#		Aho-Corasick
#		Z
#		Morris-Pratt
#		Suffix Array
#	other
#		matrix
#		biginteger
#		mod int
#		eps float


snippet main "" b
#include<cstdio>

#define MAXX ${1:100111}
int i,j,k,l,r,m,n;
int the[MAXX];

int main()
{
	${0}
	return 0;
}
endsnippet

snippet for1 "for(i=1;i<=n;++i)"
for(${1:i}=1;$1<=${2:n};${3:++$1})
	${0}
endsnippet

snippet fori1 "for(int i=1;i<=n;++i)"
for(${1:int}${2:i}=1;$2<=${3:n};${4:++$2})
	${0}
endsnippet

snippet set "std::set"
std::set<${1:int}>${2:set};
endsnippet

snippet mset "std::multiset"
std::multiset<${1:int}>${2:set};
endsnippet

snippet uset "std::unordered_set"
std::unordered_set<${1:int}>${2:hash};
endsnippet

snippet umset "std::unordered_multiset"
std::unordered_multiset<${1:int}>${2:hash};
endsnippet

snippet pair "std::pair"
std::pair<${1:int},${2:int}>$3;
endsnippet

############################################################
#----------------------data structure----------------------#
############################################################

snippet segtree "Segment Tree" b
class SegTree
{
#define MAXX ${1:100111}
#define MAX (MAXX<<2)
#define lson (id<<1)
#define rson (id<<1|1)
#define mid ((l+r)>>1)
#define lc lson,l,mid
#define rc rson,mid+1,r
#define llen (mid-l+1)	//lson length
#define rlen (r-mid)	//rson length
#define clen (r-l+1)	//current length
	class Node
	{
		public:
			//define here

			friend Node operator+(const Node &l,const Node &r)//merge
			{
				//define here
				return Node();
			}
			void set(/*int the*/)
			{
				//define here
			}
	}tree[MAX];
	int len;

	void make(int id,int l,int r,${2:int *}${3:the})
	{
		//define here
		if(l==r)
		{
			tree[id].set($3[l]);
			return;
		}
		make(lc,$3);
		make(rc,$3);
		tree[id]=tree[lson]+tree[rson];
	}
	void down(int id,int l,int r)
	{
		if(l==r)
			return;
		//define here
	}
	void update(int id,int l,int r,int ll,int rr,/*define*/int val)
	{
		down(id,l,r);
		if(ll<=l && r<=rr)
			//define here
		else
		{
			if(ll<=mid)
				update(lc,ll,rr,val);
			if(rr>mid)
				update(rc,ll,rr,val);
			tree[id]=tree[lson]+tree[rson];
		}
	}
	Node query(int id,int l,int r,int ll,int rr)
	{
		down(id,l,r);
		if(ll<=l && r<=rr)
			return tree[id];
		if(rr<=mid)
			return query(lc,ll,rr);
		if(ll>mid)
			return query(rc,ll,rr);
		return query(lc,ll,rr)+query(rc,ll,rr);
	}

	public:
	int opt;//specify the type of operation

	void init(int len,$2$3)
	{
		this->len=len;
		make(1,1,len,$3);
	}
	/*
	int qry(int l,int r)
	{
		static Node re;
		re=query(1,1,len,l,r);
		return re.sum;
	}
	void upd(int l,int r,int val)
	{
		update(1,1,len,l,r,val);
	}
	*/
#undef MAXX
#undef MAX
#undef lson
#undef rson
#undef lc
#undef rc
#undef mid
#undef llen
#undef rlen
#undef clen
}tree;
endsnippet

snippet sbt "size blanced tree" b
template<class Tp>class SizeBlanceTree
{
#define MAXX ${1:100111}
	public:
		inline void init() { rt=cnt=l[0]=r[0]=sz[0]=0; }
		inline void ins(const Tp &a) { ins(rt,a); }
		inline void del(const Tp &a) { del(rt,a); }
		inline bool find(const Tp &a) { return find(rt,a); }
		inline Tp pred(const Tp &a) { return pred(rt,a); }
		inline Tp succ(const Tp &a) { return succ(rt,a); }
		inline bool empty() { return !sz[rt]; }
		inline Tp min() { return min(rt); }
		inline Tp max() { return max(rt); }
		inline void delsmall(const Tp &a) { dels(rt,a); }
		inline int rank(const Tp &a) { return rank(rt,a); }
		inline Tp sel(const int &a) { return sel(rt,a); }
		inline Tp delsel(int a) { return delsel(rt,a); }
	private:
		int cnt,rt,l[MAXX],r[MAXX],sz[MAXX];
		Tp val[MAXX];
		inline void rro(int &pos)
		{
			int k(l[pos]);
			l[pos]=r[k];
			r[k]=pos;
			sz[k]=sz[pos];
			sz[pos]=sz[l[pos]]+sz[r[pos]]+1;
			pos=k;
		}
		inline void lro(int &pos)
		{
			int k(r[pos]);
			r[pos]=l[k];
			l[k]=pos;
			sz[k]=sz[pos];
			sz[pos]=sz[l[pos]]+sz[r[pos]]+1;
			pos=k;
		}
		inline void mt(int &pos,bool flag)
		{
			if(!pos)
				return;
			if(flag)
				if(sz[r[r[pos]]]>sz[l[pos]])
					lro(pos);
				else
					if(sz[l[r[pos]]]>sz[l[pos]])
					{
						rro(r[pos]);
						lro(pos);
					}
					else
						return;
			else
				if(sz[l[l[pos]]]>sz[r[pos]])
					rro(pos);
				else
					if(sz[r[l[pos]]]>sz[r[pos]])
					{
						lro(l[pos]);
						rro(pos);
					}
					else
						return;
			mt(l[pos],false);
			mt(r[pos],true);
			mt(pos,false);
			mt(pos,true);
		}
		void ins(int &pos,const Tp &a)
		{
			if(pos)
			{
				++sz[pos];
				if(a<val[pos])
					ins(l[pos],a);
				else
					ins(r[pos],a);
				mt(pos,a>=val[pos]);
				return;
			}
			pos=++cnt;
			l[pos]=r[pos]=0;
			val[pos]=a;
			sz[pos]=1;
		}
		Tp del(int &pos,const Tp &a)
		{
			--sz[pos];
			if(val[pos]==a || (a<val[pos] && !l[pos]) || (a>val[pos] && !r[pos]))
			{
				Tp ret(val[pos]);
				if(!l[pos] || !r[pos])
					pos=l[pos]+r[pos];
				else
					val[pos]=del(l[pos],val[pos]+1);
				return ret;
			}
			else
				if(a<val[pos])
					return del(l[pos],a);
				else
					return del(r[pos],a);
		}
		bool find(int &pos,const Tp &a)
		{
			if(!pos)
				return false;
			if(a<val[pos])
				return find(l[pos],a);
			else
				return (val[pos]==a || find(r[pos],a));
		}
		Tp pred(int &pos,const Tp &a)
		{
			if(!pos)
				return a;
			if(a>val[pos])
			{
				Tp ret(pred(r[pos],a));
				if(ret==a)
					return val[pos];
				else
					return ret;
			}
			return pred(l[pos],a);
		}
		Tp succ(int &pos,const Tp &a)
		{
			if(!pos)
				return a;
			if(a<val[pos])
			{
				Tp ret(succ(l[pos],a));
				if(ret==a)
					return val[pos];
				else
					return ret;
			}
			return succ(r[pos],a);
		}
		Tp min(int &pos)
		{
			if(l[pos])
				return min(l[pos]);
			return val[pos];
		}
		Tp max(int &pos)
		{
			if(r[pos])
				return max(r[pos]);
			return val[pos];
		}
		void dels(int &pos,const Tp &v)
		{
			if(!pos)
				return;
			if(val[pos]<v)
			{
				pos=r[pos];
				dels(pos,v);
				return;
			}
			dels(l[pos],v);
			sz[pos]=1+sz[l[pos]]+sz[r[pos]];
		}
		int rank(const int &pos,const Tp &v)
		{
			if(val[pos]==v)
				return sz[l[pos]]+1;
			if(v<val[pos])
				return rank(l[pos],v);
			return rank(r[pos],v)+sz[l[pos]]+1;
		}
		Tp sel(const int &pos,const int &v)
		{
			if(sz[l[pos]]+1==v)
				return val[pos];
			if(v>sz[l[pos]])
				return sel(r[pos],v-sz[l[pos]]-1);
			return sel(l[pos],v);
		}
		Tp delsel(int &pos,int k)
		{
			--sz[pos];
			if(sz[l[pos]]+1==k)
			{
				Tp re(val[pos]);
				if(!l[pos] || !r[pos])
					pos=l[pos]+r[pos];
				else
					val[pos]=del(l[pos],val[pos]+1);
				return re;
			}
			if(k>sz[l[pos]])
				return delsel(r[pos],k-1-sz[l[pos]]);
			return delsel(l[pos],k);
		}
#undef MAXX
};
${0}
endsnippet

########################################################
#----------------------geometrics----------------------#
########################################################

###################################################
#----------------------graph----------------------#
###################################################

snippet edge "the edge list in graph" b
#define MAXN ${1:100111}
#define MAXM ${2:1000111}

int edge[MAXN],next[MAXM],to[MAXM],cost[MAXM],cnt;

void add(int a,int b,int c)
{
	to[++cnt]=b;
	cost[cnt]=c;
	next[cnt]=edge[a];
	edge[a]=cnt;
}
endsnippet

snippet dijkstra "" b
#include<cstring>
#include<set>
#include<algorithm>

inline void dijkstra(int n,int s,int *dist)
{
	typedef std::pair<int,int>pii;
	std::multiset<pii>q;
	static int a,b,i;
	memset(dist,0x3f,(n+1)*(sizeof(int)));

	dist[s]=0;
	q.insert(pii(0,s));
	while(!q.empty())
	{
		a=q.begin()->second;
		b=q.begin()->first;
		q.erase(q.begin());
		if(b>dist[a])
			continue;
		for(i=edge[a];i;i=next[i])
			if(dist[to[i]]>b+cost[i])
			{
				dist[to[i]]=b+cost[i];
				q.insert(pii(dist[to[i]],to[i]));
			}
	}
}
endsnippet

####################################################
#----------------------string----------------------#
####################################################


###################################################
#----------------------other----------------------#
###################################################

#not tested yet
snippet matrix "Matrix class in math" b
template<class Tp,int n>class Matrix
{
public:
	Tp a[n][n];
	void init() { memset(a,0,sizeof a); }
	inline Matrix<Tp,n> operator*(const Matrix<Tp,n> &b)const
	{
		static Matrix<Tp,n> re;
		static int i,j,k;
		re.init();
		for(k=0;k<n;++k)
			for(i=0;i<n;++i)
				if(a[i][k])	//	caution here
					for(j=0;j<n;++j)
						if(b.a[k][j])	//	caution here
							re.a[i][j]+=a[i][k]*b.a[k][j];
		return re;
	}
	inline Matrix<Tp,n> operator^(int y)const
	{
		static Matrix<Tp,n> re,x;
		static int i,j;
		for(i=0;i<n;++i)
		{
			for(j=0;j<n;++j)
			{
				re.a[i][j]=0;
				x.a[i][j]=a[i][j];
			}
			re.a[i][i]=1;
		}
		for(;y;y>>=1,x=x*x)
			if(y&1)
				re=re*x;
		return re;
	}
};
endsnippet
